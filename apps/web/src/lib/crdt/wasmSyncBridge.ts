/**
 * WASM Sync Bridge - Unified sync client for WASM/web platform.
 *
 * This module bridges the WasmSyncClient (Rust) with JavaScript WebSocket connections.
 * All sync protocol logic is handled in Rust; this TypeScript code only:
 *
 * 1. Creates and manages WebSocket connections (browser API)
 * 2. Forwards incoming messages to Rust via inject*Message()
 * 3. Polls for outgoing messages from Rust and sends them via WebSocket
 * 4. Handles reconnection with exponential backoff
 *
 * ## Architecture
 *
 * ```
 * ┌─────────────────────────────────────────────────────────────┐
 * │                    WasmSyncBridge (this file)               │
 * │  ┌────────────────────┐       ┌────────────────────┐        │
 * │  │ Metadata WebSocket │       │ Body WebSocket     │        │
 * │  └─────────┬──────────┘       └─────────┬──────────┘        │
 * │            │                            │                   │
 * └────────────┼────────────────────────────┼───────────────────┘
 *              │                            │
 * ┌────────────┼────────────────────────────┼───────────────────┐
 * │            ▼                            ▼                   │
 * │      ┌──────────────────────────────────────────┐           │
 * │      │           WasmSyncClient (Rust)          │           │
 * │      │   - Message processing                   │           │
 * │      │   - Y-sync protocol                      │           │
 * │      │   - subscribe_all_bodies()               │           │
 * │      └──────────────────────────────────────────┘           │
 * │                      WASM Layer                              │
 * └──────────────────────────────────────────────────────────────┘
 * ```
 */

import type { Backend } from '../backend/interface';

// Import types that will be generated by wasm-bindgen
// In actual usage, this comes from the WASM module
interface WasmSyncClient {
  getMetadataUrl(): string | null;
  getBodyUrl(): string | null;
  markMetadataConnected(): void;
  markMetadataDisconnected(): void;
  markBodyConnected(): void;
  markBodyDisconnected(): void;
  injectMetadataMessage(message: Uint8Array): Promise<Uint8Array | null>;
  injectBodyMessage(docName: string, message: Uint8Array): Promise<Uint8Array | null>;
  pollMetadataOutgoing(): Uint8Array | null;
  pollBodyOutgoing(): Uint8Array | null;
  hasMetadataOutgoing(): boolean;
  hasBodyOutgoing(): boolean;
  start(): Promise<void>;
  stop(): void;
  isRunning(): boolean;
  isMetadataConnected(): boolean;
  isBodyConnected(): boolean;
  isConnected(): boolean;
  getWorkspaceId(): string;
  getServerUrl(): string;
  subscribeBody(docName: string): void;
  queueWorkspaceUpdate(): void;
  queueBodyUpdate(docName: string, content: string): void;
}

/**
 * Options for creating a WasmSyncBridge.
 */
export interface WasmSyncBridgeOptions {
  /** Callback when connection status changes. */
  onStatusChange?: (connected: boolean) => void;
  /** Callback when initial sync completes. */
  onSynced?: () => void;
  /** Callback when workspace files change. */
  onFilesChanged?: (changedFiles: string[]) => void;
  /** Callback when body content changes. */
  onBodyChanged?: (docName: string, content: string) => void;
  /** Callback for sync progress updates. */
  onProgress?: (completed: number, total: number) => void;
  /** Callback for errors. */
  onError?: (error: string) => void;
}

/**
 * WASM Sync Bridge - manages WebSocket connections for WasmSyncClient.
 *
 * This class creates and manages the WebSocket connections while delegating
 * all sync protocol logic to the Rust WasmSyncClient.
 */
export class WasmSyncBridge {
  private readonly client: WasmSyncClient;
  private readonly options: WasmSyncBridgeOptions;

  private metadataWs: WebSocket | null = null;
  private bodyWs: WebSocket | null = null;
  private pollingInterval: ReturnType<typeof setInterval> | null = null;
  private destroyed = false;

  // Reconnection state
  private reconnectAttempts = 0;
  private readonly maxReconnectAttempts = 10;
  private reconnectTimeout: ReturnType<typeof setTimeout> | null = null;

  constructor(client: WasmSyncClient, options: WasmSyncBridgeOptions = {}) {
    this.client = client;
    this.options = options;
  }

  /**
   * Connect to the sync server and start syncing.
   */
  async connect(): Promise<void> {
    if (this.destroyed) {
      console.warn('[WasmSyncBridge] Cannot connect - already destroyed');
      return;
    }

    console.log('[WasmSyncBridge] Connecting...');

    try {
      // Connect both WebSockets
      await Promise.all([
        this.connectMetadata(),
        this.connectBody(),
      ]);

      // Start polling for outgoing messages
      this.startPolling();

      // Start the sync session (sends initial SyncStep1 messages)
      await this.client.start();

      console.log('[WasmSyncBridge] Connected and syncing');
    } catch (error) {
      console.error('[WasmSyncBridge] Connection failed:', error);
      this.options.onError?.(`Connection failed: ${error}`);
      this.scheduleReconnect();
    }
  }

  /**
   * Disconnect from the sync server.
   */
  disconnect(): void {
    console.log('[WasmSyncBridge] Disconnecting...');

    this.destroyed = true;
    this.stopPolling();

    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
      this.reconnectTimeout = null;
    }

    if (this.metadataWs) {
      this.metadataWs.close();
      this.metadataWs = null;
    }

    if (this.bodyWs) {
      this.bodyWs.close();
      this.bodyWs = null;
    }

    this.client.stop();
    console.log('[WasmSyncBridge] Disconnected');
  }

  /**
   * Subscribe to body sync for a specific document.
   */
  subscribeBody(docName: string): void {
    this.client.subscribeBody(docName);
  }

  /**
   * Queue a workspace update for sending.
   */
  queueWorkspaceUpdate(): void {
    this.client.queueWorkspaceUpdate();
  }

  /**
   * Queue a body update for sending.
   */
  queueBodyUpdate(docName: string, content: string): void {
    this.client.queueBodyUpdate(docName, content);
  }

  /**
   * Check if connected to both metadata and body servers.
   */
  isConnected(): boolean {
    return this.client.isConnected();
  }

  // =========================================================================
  // Private: WebSocket Connection Management
  // =========================================================================

  private async connectMetadata(): Promise<void> {
    const url = this.client.getMetadataUrl();
    if (!url) {
      throw new Error('No metadata URL available');
    }

    return new Promise((resolve, reject) => {
      console.log('[WasmSyncBridge] Connecting metadata WebSocket:', url);

      const ws = new WebSocket(url);
      ws.binaryType = 'arraybuffer';

      ws.onopen = () => {
        console.log('[WasmSyncBridge] Metadata WebSocket connected');
        this.metadataWs = ws;
        this.client.markMetadataConnected();
        this.updateConnectionStatus();
        resolve();
      };

      ws.onerror = (event) => {
        console.error('[WasmSyncBridge] Metadata WebSocket error:', event);
        reject(new Error('Metadata WebSocket connection failed'));
      };

      ws.onclose = () => {
        console.log('[WasmSyncBridge] Metadata WebSocket closed');
        this.client.markMetadataDisconnected();
        this.metadataWs = null;
        this.updateConnectionStatus();
        if (!this.destroyed) {
          this.scheduleReconnect();
        }
      };

      ws.onmessage = async (event) => {
        await this.handleMetadataMessage(event);
      };
    });
  }

  private async connectBody(): Promise<void> {
    const url = this.client.getBodyUrl();
    if (!url) {
      throw new Error('No body URL available');
    }

    return new Promise((resolve, reject) => {
      console.log('[WasmSyncBridge] Connecting body WebSocket:', url);

      const ws = new WebSocket(url);
      ws.binaryType = 'arraybuffer';

      ws.onopen = () => {
        console.log('[WasmSyncBridge] Body WebSocket connected');
        this.bodyWs = ws;
        this.client.markBodyConnected();
        this.updateConnectionStatus();
        resolve();
      };

      ws.onerror = (event) => {
        console.error('[WasmSyncBridge] Body WebSocket error:', event);
        reject(new Error('Body WebSocket connection failed'));
      };

      ws.onclose = () => {
        console.log('[WasmSyncBridge] Body WebSocket closed');
        this.client.markBodyDisconnected();
        this.bodyWs = null;
        this.updateConnectionStatus();
        if (!this.destroyed) {
          this.scheduleReconnect();
        }
      };

      ws.onmessage = async (event) => {
        await this.handleBodyMessage(event);
      };
    });
  }

  // =========================================================================
  // Private: Message Handling
  // =========================================================================

  private async handleMetadataMessage(event: MessageEvent): Promise<void> {
    if (this.destroyed) return;

    // Handle text messages (JSON control messages)
    if (typeof event.data === 'string') {
      try {
        const msg = JSON.parse(event.data);
        if (msg.type === 'sync_progress') {
          this.options.onProgress?.(msg.completed, msg.total);
        } else if (msg.type === 'sync_complete') {
          console.log('[WasmSyncBridge] Metadata sync complete');
          this.options.onSynced?.();
        }
      } catch (e) {
        console.warn('[WasmSyncBridge] Failed to parse JSON message:', e);
      }
      return;
    }

    // Handle binary sync messages
    const data = new Uint8Array(event.data);
    try {
      const response = await this.client.injectMetadataMessage(data);
      if (response && this.metadataWs?.readyState === WebSocket.OPEN) {
        this.metadataWs.send(response);
      }
    } catch (error) {
      console.error('[WasmSyncBridge] Error handling metadata message:', error);
      this.options.onError?.(`Metadata sync error: ${error}`);
    }
  }

  private async handleBodyMessage(event: MessageEvent): Promise<void> {
    if (this.destroyed) return;

    // Handle text messages (JSON control messages)
    if (typeof event.data === 'string') {
      try {
        const msg = JSON.parse(event.data);
        if (msg.type === 'sync_complete') {
          console.log('[WasmSyncBridge] Body sync complete');
        }
      } catch (e) {
        console.warn('[WasmSyncBridge] Failed to parse JSON message:', e);
      }
      return;
    }

    // Handle binary sync messages
    // Body messages are framed: [varUint(pathLen)] [pathBytes] [message]
    const data = new Uint8Array(event.data);
    const { docName, message } = this.unframeBodyMessage(data);

    if (!docName) {
      console.warn('[WasmSyncBridge] Failed to unframe body message');
      return;
    }

    try {
      const response = await this.client.injectBodyMessage(docName, message);
      if (response && this.bodyWs?.readyState === WebSocket.OPEN) {
        // Frame the response before sending
        const framed = this.frameBodyMessage(docName, response);
        this.bodyWs.send(framed);
      }
    } catch (error) {
      console.error(`[WasmSyncBridge] Error handling body message for ${docName}:`, error);
      this.options.onError?.(`Body sync error for ${docName}: ${error}`);
    }
  }

  // =========================================================================
  // Private: Message Framing (matches Rust frame_body_message)
  // =========================================================================

  private frameBodyMessage(docName: string, message: Uint8Array): Uint8Array {
    const encoder = new TextEncoder();
    const pathBytes = encoder.encode(docName);

    // Write varUint for path length
    const lenBytes = this.encodeVarUint(pathBytes.length);

    const result = new Uint8Array(lenBytes.length + pathBytes.length + message.length);
    result.set(lenBytes, 0);
    result.set(pathBytes, lenBytes.length);
    result.set(message, lenBytes.length + pathBytes.length);

    return result;
  }

  private unframeBodyMessage(data: Uint8Array): { docName: string | null; message: Uint8Array } {
    if (data.length < 2) {
      return { docName: null, message: data };
    }

    // Read varUint for path length
    const { value: pathLen, bytesRead } = this.decodeVarUint(data);
    if (pathLen === 0 || bytesRead + pathLen > data.length) {
      return { docName: null, message: data };
    }

    const pathBytes = data.slice(bytesRead, bytesRead + pathLen);
    const decoder = new TextDecoder();
    const docName = decoder.decode(pathBytes);

    const message = data.slice(bytesRead + pathLen);

    return { docName, message };
  }

  private encodeVarUint(value: number): Uint8Array {
    const bytes: number[] = [];
    while (value > 0x7f) {
      bytes.push((value & 0x7f) | 0x80);
      value >>>= 7;
    }
    bytes.push(value & 0x7f);
    return new Uint8Array(bytes);
  }

  private decodeVarUint(data: Uint8Array): { value: number; bytesRead: number } {
    let value = 0;
    let shift = 0;
    let bytesRead = 0;

    for (let i = 0; i < data.length && i < 5; i++) {
      const byte = data[i];
      bytesRead++;
      value |= (byte & 0x7f) << shift;
      if ((byte & 0x80) === 0) {
        break;
      }
      shift += 7;
    }

    return { value, bytesRead };
  }

  // =========================================================================
  // Private: Outgoing Message Polling
  // =========================================================================

  private startPolling(): void {
    if (this.pollingInterval) return;

    // Poll every 50ms for outgoing messages
    this.pollingInterval = setInterval(() => {
      this.sendPendingMessages();
    }, 50);
  }

  private stopPolling(): void {
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
      this.pollingInterval = null;
    }
  }

  private sendPendingMessages(): void {
    // Send pending metadata messages
    if (this.metadataWs?.readyState === WebSocket.OPEN) {
      let msg: Uint8Array | null;
      while ((msg = this.client.pollMetadataOutgoing()) !== null) {
        this.metadataWs.send(msg);
      }
    }

    // Send pending body messages
    if (this.bodyWs?.readyState === WebSocket.OPEN) {
      let msg: Uint8Array | null;
      while ((msg = this.client.pollBodyOutgoing()) !== null) {
        this.bodyWs.send(msg);
      }
    }
  }

  // =========================================================================
  // Private: Reconnection
  // =========================================================================

  private updateConnectionStatus(): void {
    const connected = this.client.isConnected();
    this.options.onStatusChange?.(connected);
  }

  private scheduleReconnect(): void {
    if (this.destroyed || this.reconnectTimeout) return;

    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.error('[WasmSyncBridge] Max reconnection attempts reached');
      this.options.onError?.('Max reconnection attempts reached');
      return;
    }

    // Exponential backoff: 1s, 2s, 4s, 8s, 16s, 32s (max)
    const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 32000);
    this.reconnectAttempts++;

    console.log(`[WasmSyncBridge] Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})`);

    this.reconnectTimeout = setTimeout(async () => {
      this.reconnectTimeout = null;

      // Clean up old connections
      if (this.metadataWs) {
        this.metadataWs.close();
        this.metadataWs = null;
      }
      if (this.bodyWs) {
        this.bodyWs.close();
        this.bodyWs = null;
      }

      // Try to reconnect
      this.destroyed = false; // Allow reconnection
      await this.connect();
    }, delay);
  }
}

/**
 * Create a WasmSyncBridge from a backend that supports createSyncClient.
 */
export async function createWasmSyncBridge(
  backend: Backend,
  serverUrl: string,
  workspaceId: string,
  authToken?: string,
  options: WasmSyncBridgeOptions = {}
): Promise<WasmSyncBridge | null> {
  // Check if backend supports the new API
  if (!('createSyncClient' in backend) || typeof (backend as any).createSyncClient !== 'function') {
    console.log('[WasmSyncBridge] Backend does not support createSyncClient');
    return null;
  }

  try {
    const client = (backend as any).createSyncClient(serverUrl, workspaceId, authToken) as WasmSyncClient;
    return new WasmSyncBridge(client, options);
  } catch (error) {
    console.error('[WasmSyncBridge] Failed to create sync client:', error);
    return null;
  }
}
