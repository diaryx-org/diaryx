//! Markdown file import — parse `.md` files into [`ImportedEntry`] values.
//!
//! This parser handles markdown files from Obsidian, Logseq, Bear, iA Writer,
//! or any markdown-based tool. It preserves existing frontmatter, extracts
//! title and date, and returns the file as an [`ImportedEntry`].
//!
//! This parser is a pure function (no I/O) — callers provide the raw bytes.

use serde_yaml::Value;

use super::ImportedEntry;

/// Parse a single markdown file into an [`ImportedEntry`].
///
/// # Title extraction (priority order)
/// 1. Frontmatter `title` property
/// 2. First `# heading` in body (stripped from body content)
/// 3. Filename stem, title-cased (`my_notes.md` → `"My Notes"`)
///
/// # Date extraction (priority order)
/// 1. Frontmatter `date` property (parsed via chrono)
/// 2. `None`
///
/// # Frontmatter handling
/// - All existing key-value pairs are preserved as `metadata`
/// - `title`, `date`, `part_of`, `contents` are removed from metadata
///   (they go to dedicated fields or are regenerated by the CLI handler)
pub fn parse_markdown_file(bytes: &[u8], filename: &str) -> Result<ImportedEntry, String> {
    let content =
        std::str::from_utf8(bytes).map_err(|e| format!("Invalid UTF-8 in {filename}: {e}"))?;

    let parsed = crate::frontmatter::parse_or_empty(content)
        .map_err(|e| format!("Failed to parse frontmatter in {filename}: {e}"))?;

    let mut metadata = parsed.frontmatter;
    let body = parsed.body;

    // Extract title from frontmatter
    let fm_title = metadata
        .get("title")
        .and_then(|v| v.as_str())
        .map(|s| s.to_string());
    metadata.shift_remove("title");

    // Extract date from frontmatter
    let date = metadata.get("date").and_then(|v| match v {
        Value::String(s) => parse_date(s),
        _ => None,
    });
    metadata.shift_remove("date");

    // Remove hierarchy keys (regenerated by CLI handler)
    metadata.shift_remove("part_of");
    metadata.shift_remove("contents");

    // Determine title: frontmatter > first heading > filename stem
    let (title, body) = if let Some(t) = fm_title {
        (t, body)
    } else {
        extract_title_from_body(&body, filename)
    };

    Ok(ImportedEntry {
        title,
        date,
        body,
        metadata,
        attachments: Vec::new(),
    })
}

/// Try to extract a title from the first `# heading` line.
/// Falls back to prettified filename stem.
fn extract_title_from_body(body: &str, filename: &str) -> (String, String) {
    let trimmed = body.trim_start();

    if let Some(rest) = trimmed.strip_prefix("# ") {
        if let Some(newline_pos) = rest.find('\n') {
            let title = rest[..newline_pos].trim().to_string();
            let remaining = rest[newline_pos + 1..].to_string();
            if !title.is_empty() {
                return (title, remaining);
            }
        } else {
            // Entire body is the heading
            let title = rest.trim().to_string();
            if !title.is_empty() {
                return (title, String::new());
            }
        }
    }

    // Fall back to filename stem, title-cased
    let stem = std::path::Path::new(filename)
        .file_stem()
        .and_then(|s| s.to_str())
        .unwrap_or("Untitled");
    let title = crate::entry::prettify_filename(stem);
    (title, body.to_string())
}

/// Parse a date string using chrono, trying multiple formats.
fn parse_date(s: &str) -> Option<chrono::DateTime<chrono::Utc>> {
    use chrono::{NaiveDate, NaiveDateTime, TimeZone, Utc};

    // Try RFC 3339 / ISO 8601 with timezone
    if let Ok(dt) = chrono::DateTime::parse_from_rfc3339(s) {
        return Some(dt.with_timezone(&Utc));
    }

    // Try ISO 8601 without timezone (assume UTC)
    if let Ok(dt) = NaiveDateTime::parse_from_str(s, "%Y-%m-%dT%H:%M:%S") {
        return Some(Utc.from_utc_datetime(&dt));
    }

    // Try date-only formats
    for fmt in &["%Y-%m-%d", "%Y/%m/%d", "%d-%m-%Y", "%m/%d/%Y"] {
        if let Ok(date) = NaiveDate::parse_from_str(s, fmt) {
            let dt = date.and_hms_opt(0, 0, 0)?;
            return Some(Utc.from_utc_datetime(&dt));
        }
    }

    None
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_with_frontmatter_title() {
        let content =
            b"---\ntitle: My Note\ndate: 2024-01-15\ntags:\n  - rust\n---\nBody content here.";
        let entry = parse_markdown_file(content, "my_note.md").unwrap();
        assert_eq!(entry.title, "My Note");
        assert!(entry.date.is_some());
        assert_eq!(entry.body, "Body content here.");
        // title and date removed from metadata, tags preserved
        assert!(entry.metadata.get("title").is_none());
        assert!(entry.metadata.get("date").is_none());
        assert!(entry.metadata.get("tags").is_some());
    }

    #[test]
    fn test_parse_with_heading_title() {
        let content = b"# My Heading\nBody after heading.";
        let entry = parse_markdown_file(content, "whatever.md").unwrap();
        assert_eq!(entry.title, "My Heading");
        assert_eq!(entry.body, "Body after heading.");
    }

    #[test]
    fn test_parse_fallback_to_filename() {
        let content = b"Just body content, no title.";
        let entry = parse_markdown_file(content, "my_cool_notes.md").unwrap();
        assert_eq!(entry.title, "My Cool Notes");
        assert_eq!(entry.body, "Just body content, no title.");
    }

    #[test]
    fn test_parse_strips_hierarchy_keys() {
        let content = b"---\ntitle: Test\npart_of: '[Parent](/parent.md)'\ncontents:\n  - '[Child](/child.md)'\ncustom: value\n---\nBody.";
        let entry = parse_markdown_file(content, "test.md").unwrap();
        assert_eq!(entry.title, "Test");
        assert!(entry.metadata.get("part_of").is_none());
        assert!(entry.metadata.get("contents").is_none());
        assert_eq!(
            entry.metadata.get("custom").unwrap(),
            &Value::String("value".to_string())
        );
    }

    #[test]
    fn test_parse_date_formats() {
        // RFC 3339
        assert!(parse_date("2024-01-15T10:30:00Z").is_some());
        // ISO without timezone
        assert!(parse_date("2024-01-15T10:30:00").is_some());
        // Date only
        assert!(parse_date("2024-01-15").is_some());
        // Invalid
        assert!(parse_date("not a date").is_none());
    }

    #[test]
    fn test_parse_empty_file() {
        let entry = parse_markdown_file(b"", "empty.md").unwrap();
        assert_eq!(entry.title, "Empty");
        assert_eq!(entry.body, "");
    }

    #[test]
    fn test_parse_frontmatter_only() {
        let content = b"---\ntitle: Just Frontmatter\n---\n";
        let entry = parse_markdown_file(content, "test.md").unwrap();
        assert_eq!(entry.title, "Just Frontmatter");
        assert_eq!(entry.body, "");
    }

    #[test]
    fn test_frontmatter_title_takes_priority_over_heading() {
        let content = b"---\ntitle: FM Title\n---\n# Heading Title\nBody.";
        let entry = parse_markdown_file(content, "test.md").unwrap();
        assert_eq!(entry.title, "FM Title");
        // Heading is NOT stripped when frontmatter title exists
        assert!(entry.body.contains("# Heading Title"));
    }
}
